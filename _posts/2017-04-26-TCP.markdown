---
title:  "TCP/IP"
categories: [Network]
tags: [Network]
---

### 1. TCP(Transmission Control Protocol)    

: 전송제어 프로토콜로, TCP는 통신망을 이용하여 서로 연결된 망 내에서 실행되는 Application간의 *옥텟을 순서대로 교환하는 프로토콜이다.(IETF RFC-793)    
> **옥텟**(Octet) : 8개의 Bit가 한데 모인 것 = 바이트(byte)    

TCP는 데이터 스트림으로부터 데이터를 받아들여 이것을 *청크 단위로 분할 한 뒤, *TCP Header를 덧붙여 TCP Segment를 생성한다. 생성된 TCP Segment는 IP 데이터그램(IP Packet)에 캡슐화 되어 전달된다.
> **청크**(Chunk) : Data 덩어리, Data의 단위. TCP/IP를 이용하여 전달되는 Packet(TCP Segment) 내 실제 Data에 해당하는 부분으로 전체 Data의 일부분이다. Chunk의 종류에 따라 Content-Type을 확인할 수도 있다.    

TCP 전송의 기본단위가 TCP Segment이며, Header와 Data로 구성된다.    

![TCP Segment](https://parkmh04.github.io/images/TCP-segment.png)    

**TCP Header**(TCP 전송에 필요한 Meta정보, WIKI 발췌)  

```
Source port(16 비트)
: 송신 포트

Destination port(16 비트)    
: 수신 포트    

Sequence number (32 비트)    
: SYN 플래그가 (1)로 설정된 경우, 이것은 초기 시퀀스 번호가 된다. 실제 데이터의 최초 바이트 값과 그에 상응하는 ACK 번호는 이 값에 1을 더한 값이 된다. SYN 플래그가 (0)으로 해제된 경우, 이것은 현재 세션의 이 세그먼트 데이터의 최초 바이트 값의 누적 시퀀스 번호이다.    

Acknowledgment number (32 비트)    
: ACK 플래그가 설정된 경우 이 필드의 값은 수신자가 예상하는 다음 시퀀스 번호이다. 이것은 모든 선행하는 바이트들(존재할 경우)에 대한 수신에 대한 확인응답이 된다. 한쪽이 보낸 최초의 ACK는 반대쪽의 초기 시퀀스 번호 자체에 대한 확인응답이 되며, 데이터에 대한 응답은 포함되지 않는다.    

Header Length (4 비트)    
: 32-bit 워드 단위로 나타낸 TCP 헤더 크기값이다. 헤더의 최소 크기는 5 워드이며 최대 크기는 15 워드이다.    

Reserved (3 비트)    
: 미래에 사용하기 위해 남겨둔 예비 필드이며 0으로 채워져야 한다.    

Control bits (9 bits)    
: 9개의 1-비트 플래그를 포함    
 - NS   (1 비트) – ECN-nonce 은폐 보호(RFC 3540에 의해 헤더에 추가)    
 - CWR (1 비트) – 혼잡 윈도 축소(Congestion Window Reduced) 플래그는 송신측 호스트에 의해 설정되는 것으로, 호스트가 ECE 플래그가 포함된 TCP 세그먼트를 수신했으며 혼잡 제어 메커니즘에 의해 응답했음을 알리는 역할을 한다(RFC 3168에 의해 헤더에 추가).  
 - ECE  (1 비트) – ECN-Echo는 다음을 나타낸다.  
   : SYN 플래그가 (1)로 설정된 경우, TCP 상대가 명시적 혼잡 통지(Explicit Congestion Notification, ECN)가 가능함을 의미한다.  
     SYN 플래그가 (0)으로 해제된 경우, IP 헤더 셋에 혼잡 경험(Congestion Experienced) 플래그가 설정된 패킷이 정상적인 전송 중에 수신되었다는 것을 의미한다(RFC 3168에 의해 헤더에 추가).  
 - URG (1 비트) – Urgent pointer 필드의 값이 유효함을 나타낸다.  
 - ACK (1 비트) – Acknowledgment 필드의 값이 유효함을 나타낸다. 클라이언트가 보낸 최초의 SYN 패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어 있어야 한다.  
 - PSH (1 비트) – 푸시 기능. 수신 애플리케이션에 버퍼링된 데이터를 푸시해 줄지 여부를 질의하는 역할을 한다.  
 - RST (1 비트) – 커넥션 리셋  
 - SYN (1 비트) – 동기화 시퀀스 번호. 양쪽이 보낸 최초의 패킷에만 이 플래그가 설정되어 있어야 한다. 다른 일부 플래그들의 의미가 이 플래그의 값에 따라 바뀌며, 일부 플래그들은 이 플래그가 설정되어 있을 때만 유효하고, 또 다른 일부 플래그들은 이 플래그가 해제되어 있을 때에만 유효하다.  
 - FIN (1 비트) – 남은 송신측 데이터 없음    

Window size (16 비트)    
: 수신 윈도의 크기. 해당 세그먼트의 송신측이 현재 수신하고자 하는 윈도 크기(기본 단위는 바이트). acknowledgment 필드의 시퀀스 번호보다 큰 값이어야 한다.    

Checksum (16 비트)    
: 헤더 및 데이터의 에러 확인을 위해 사용되는 16 비트 체크섬 필드    

Urgent pointer (16 비트)    
: URG 플래그가 설정된 경우, 이 16 비트 필드는 시퀀스 번호로부터의 오프셋을 나타낸다. 이 오프셋이 마지막 긴급 데이터 바이트를 가리킨다.    

Options(가변 0–320 비트, 32의 배수)    
: 이 필드의 길이는 데이터 오프셋 필드에 의해 결정된다. 이 부분은 Option-Kind (1 바이트, 옵션 종류), Option-Length (1 바이트, 옵션 길이), Option-Data (가변, 옵션의 값) 이렇게 최대 3개의 필드로 구성될 수 있다    

Padding    
TCP 헤더 패딩은 TCP 헤더의 종료 지점과 데이터의 시작 지점을 32 비트 단위 길이에 맞추기 위해 사용된다. 패딩의 값은 0이다.    
```

Application 간 TCP/IP를 이용해 통신을 한다는 것은 결국, **전송할 Data를 Chunk단위로 나누어 TCP Header를 붙여 TCP Segment를 생성하고, 이것을 IP Datagram에 담아 전달하는 것**을 의미한다.    

---
### 2. IP(Internet Protocol)    



> 데이터그램(Datagram) : IP 계층의 Packet에 해당하며 버전, 헤더길이, 서비스타입, 전체길이, 식별자, 플래그, 단편화옵셋, 수명, 프로토콜, 검사합, 송신자 IP주소, 수신자 IP주소, 옵션 등으로 이루어져 있다.

버전(Version)
  - IP프로토콜의 버전을 의미
    = IPv4 = 0100, IPv6 = 0110
  - 버전에 따라 헤더 구성이 다르므로, 올바른 해석을 위해 IP버전 정보가 필요함
  - 버전이 맞지 않은 경우에는 폐기함
 
헤더길이(Header Length)
  - 4바이트 단위로 표현
  - 표현가능한 길이 : (2^4 - 1) x 4 (바이트단위) = 60
  - 헤더 최소길이 : 20바이트 (헤더길이 부분에 들어가는 실제값 = 5)
  - 헤더 최대길이 : 60바이트 (헤더길이 부분에 들어가는 실제값 = 15)
    * 실제값은 4바이트 단위로 들어감
 
서비스타입(Differentiated Services)
  - QoS 제공을 위해 사용함
    * QoS : Quality of Service의 약어로, 인터넷이나 네트워크 상에서 전송율, 에러율과
                관련된 서비스 품질을 의미함
 
전체길이 (Total Length)
  - 헤더와 데이터 길이를 합한 길이
  - 전체길이의 최대값 : 2^16 - 1 = 65,535
  - 데이터 길이 = 전체길이 - 헤더길이
    * 헤더길이 20 ~ 60바이트
  - 전체길이 필드가 필요한 이유 : 실제 데이터와 패딩을 구분해야 하기 때문임
 
식별자(Identification)
  - 데이터그램이 단편화되어 전송된 후, 재조립할 때 이용됨
  - 식별자 필드는 중복되지 않아야 함 = 유일해야 함
  - 카운터를 이용해 데이터그램을 보낼때 마다 카운터 값을 1씩 증가
  - 모든 단편화된 단편의 헤더에는 식별자 필드가 포함
 
플래그(Flag)
  - 데이터그램의 상태나 진위를 나타내기 위한 변수
  - 데이터그램의 헤더에 들어가는 플래그는 D와 M으로 구성
    = D : Do not Fragment (D값이 1이면 단편화를 하지 않고, 0이면 단편화를 함)
    = M : More Fragment (M값이 1이면 마지막 단편이 아님, 0이면 마지막 단편임)
 
단편옵셋(Fragmentation Offset)
  - 단편화 되기 전 데이터 시작점으로 부터의 차이
  - 즉, 전체 데이터그램에서 단편에 포함된 데이터의 시작 위치
  - 8바이트 단위로 표시
    = 전체길이 필드가 16비트라서, 단편옵셋도 16비트 만큼 표시가 가능해야 하지만
       3비트를 플래그 표시에 사용했으므로, 남은 13비트로 16비트를 표현하기 위해
  - 예) 첫번째 단편의 옵셋 값은 0
    = 첫번째 단편이므로 시작 위치가 0임
  - 예) 두번째 단편부터는 이전에 단편화된 길이를 8로 나누어 계산
    = 만약, 첫번째가 800바이트였다면 두번째 단편화 옵셋 값은 100
 
수명(Time to Live)
  - 데이터그램의 수명제한을 위해 사용
  - 데이터그램들의 송수신 과정에서 상위계층 프로토콜을 혼란시킬 수 있으므로,
     수명제한을 통해 오래된 데이터그램은 폐기
  - 홉 수로 수명이 표시
    = 라우터가 데이터크램을 처리할 때마다 수명값은 1홉씩 감소
    = 0이 되면, 라우터에서 데이터그램 폐기
  - 송신지에서 수명 값을 지정하여 송신
    = 일반적으로 예상 경로에 속한 라우터 수의 두배 만큼 지정
    = 만약 1로 지정할 경우 데이터그램은 라우터를 벗어나지 못하고 폐기됨
 
프로토콜(Protocol)
  - 데이터그램을 처리한 후, 전달될 상위프로토콜을 표시
  - IP프로토콜은 다양한 상위프로토콜을 다중화, 역다중화하기 때문에 필요
 
검사합(Checksum)
  - 수신한 데이타그램 내의 에러여부 확인
 
발신지주소(Source Address)
  - 발신지의 IP주소
 
목적지주소(Destination Address)
  - 목적지의 IP주소
[출처] IP (Internet Protocol) - 데이터그램 (Datagram)|작성자 Just Blue
![IP Datagram](https://parkmh04.github.io/images/ip_datagram.png)    

로 분할한 뒤 TCP 헤더를 덧붙여 TCP 세그먼트를 생성한다. TCP 세그먼트는 IP 데이터그램에 캡슐화되어 상대방과 주고 받게 된다.
TCP 패킷이라는 용어가 종종 사용되지만 이는 정확한 표현이 아니다. 세그먼트가 TCP 프로토콜 데이터 유닛(PDU)을 의미하는 정확한 표현이며 데이터그램[3] 은 IP PDU를, 프레임은 데이터 링크 계층 PDU를 의미한다.
프로세스는 TCP를 통해 데이터 버퍼를 인수로 넘겨 줌으로써 데이터를 전송한다. TCP는 이 버퍼들을 묶어 세그먼트를 생성하여 인터넷 모듈(IP 등)을 통해 목적지의 TCP로 각각의 세그먼트들을 전송한다.
TCP 세그먼트는 세그먼트 헤더와 데이터의 두 섹션으로 구성된다. TCP 헤더는 10개의 필수 필드 및 옵션 확장 필드(표 하단의 주황색 부분)들을 포함한다.

헤더 뒤에는 데이터 섹션이 따라 온다. 그 내용은 애플리케이션의 페이로드 데이터이다. 데이터 섹션의 길이는 TCP 세그먼트 헤더에서 결정되지 않으며, 전체 IP 데이터그램의 길이에서 TCP 헤더와 캡슐화된 IP 헤더의 길이를 뺀 값으로 계산하게 된다. 즉, 데이터 섹션의 길이는 IP 헤더에 의해 결정된다.


- HTTP는 웹환경에서 사용하는 TCP/IP 기반의 응용프로토콜이다. 
- HTTP는 연결상태를 유지하지 않는 통신규약이다. (연결상태를 유지 - FTP, Telnet)
- HTTP는 Request - Response가 1:1로 호환된다.(Sync)
- HTTP에서 HyperText의 의미는 데이터 자체를 전송하기보다는 링크기반으로 데이터에 접근하겠다는 의미이다.
- Client - Server 방식으로 동작한다.(요청과 응답)    

![HTTP](https://parkmh04.github.io/images/http.PNG)    

---
## 2. Connectless Protocol

: HTTP는 클라이언트가 서버에 요청하고, 응답을 받으면 연결을 유지하지 않고 끊어버린다. 이러한 방식으로 인해 하기와 같은 특징이 있다.    

- **장점** : 불특정 다수를 대상으로 서비스가 가능하다. 계속해서 새로운 클라이언트와 연결하고 연결을 해지하기 때문에 더 많은 클라이언트의 요청을 처리할 수 있다.    

- **단점** : 요청한 클라이언트와의 이전 요청에 대한 결과 등과 같은 클라이언트의 이전상태를 알 수 없다. 로그인 세션 등의 정보를 유지할 수 없다.    

따라서 Cookie를 사용하여 클라이언트의 이전상태를 확인한다.Cookie는 클라이언트와 서버의 상태 정보를 가지고 있기 때문이다.(DB를 이용하여 클라이언트 정보와 상태를 저장하기도 한다.)    

---
### 3. HTTP Method    

: Method는 클라이언트의 요청방식이다.    

일반적으로 HTTP POST, HTTP GET을 이용하여 개발을 진행한다.  그렇게 해도 상관없기 때문이다. 하지만 실제로 HTTP 규격에서는 HTTP의 Method를 아래와 같이 구분하고 있다.    

- **GET**(SELECT) : 데이터를 요청한다.  
- **POST**(INSERT) : 데이터를  삽입한다.  
- **PUT**(UPDATE) : 데이터를 업데이트한다.  
- **DELETE**(DELETE) : 데이터를 삭제한다.  
- **HEAD**(CHECK) : HTTP  Header 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.  
- **OPTIONS** : 웹서버가 지원하는 HTTP Mehtod 목록을 요청한다.  
- **TRACE** : 클라이언트의 요청을 그대로 반환한다.    

Ref : [HTTP의 Method](https://www.tutorialspoint.com/http/http_methods.htm){: target="_blank" }    

---
- **RESTFUL 과 HTTP Method**    
: 흔히 Restful API를 설계/개발한다고들 한다. Restful의 제약사항/목표는 여러가지 것들이 존재하지만, HTTP Method 관점에서 Restful하다는 것은 HTTP Method들을 원래의 목적에 맞게 사용하는 것을 의미한다.    

1. **회원 가입 URI** : [POST] /admin/member    
2. **회원 수정 URI** : [PUT] /admin/member    
3. **회원 조회 URI** : [GET] /admin/member    
4. **회원 삭제 URI** : [DELETE] /admin/member    

---
### 4. HTTP Status Code    

: HTTP Response 의 상태코드    

- **1xx** : Informational - 정보교환영  
- **2xx** : Success - 성공(방식에 따라 다름)  
- **200** : OK	- 성공  
- **3xx** : Redirection - 방향 지정(해당페이지로 이동합니다.)  
- **301** : Moved Permanently - 요청 페이지의 영구적인 위치 변화  
- **302** : Found	- 요청 페이지의 일시적인 위치 변화  
- **4xx** : Client Error - 클라이언트 오류  
- **404** : Not Found - 요청받은 자원을 서버에서 찾을 수 없을때 나타나는 상태  
- **405** : Method Not Allowed - 서버에서 사용자가 요청한 주소의 메소드를 지원하지 않을때 나타남  
- **5xx** : server Error - 서버 오류    

---
### 5. HTTP 1.0  VS HTTP 1.1 VS HTTP/2    
  
- **HTTP 1.0**    

1. Client,  IP Adress가 1:1  
2. 매번 필요시 Connection을 Open / Close  
3. 하나의 Request/Response에 요청 신규 Connection 생성    

- **HTTP 1.1**(HTTP 1.0 호환)    

1. Client,  IP Adress가 1:N(하나의 IP Adress로 여러개의 WebSite 연결 가능, HTTP Request Header에 Host를 사용해야함.)  
2. 필요시 Multi Connection을 Open / Close    
3. 여러개의 Request/Response들이 기존 Connection 활용 가능    
4. OPTION HTTP Method 지원    
5. 캐싱 기능 제공   
6. HTTP Status Code 추가    

- **HTTP 2.0**(HTTP 1.1 호환)    

1. HTTP Header 데이터 압축(웹페이지 렌더링 시 요청 횟수를 줄여줌)  
2. Server Push 추가(Client 요청 없이 Server에서 Resource 제공 가능)  
Ref : [HTTP의 변화](http://sejoong.github.io/dev/2015/02/15/dev/){: target="_blank" }


Ref : 
[WIKI-TCP](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C){: target="_blank" }    
[WIKI-IP](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C){: target="_blank" }    
[IP Datagram](http://blog.naver.com/PostView.nhn?blogId=twers&logNo=50117746348&categoryNo=14&viewDate=&currentPage=1&listtype=0){: target="_blank" }    
[HTTP의 변화](http://sejoong.github.io/dev/2015/02/15/dev/){: target="_blank" }    
