---
title:  "JVM"
categories: [JAVA]
tags: [JAVA]
---

### 1. JVM(Java Vertual Machine)    

: JAVA를 배우게 되면, 제일 먼저 듣는 이야기가 바로 **WORA**(WORA : Write Once Run Anywhere) 사상이다. WORA는 JAVA Code가 JVM 기반에서 실행되기 때문에, 멀티 플랫폼(Windows, Mac. Linux, Unix, OS X 등) 환경에서 하나의 Code로 작성된 프로그램의 동작을 보장한다는 것을 의미한다.    

일반적으로 프로그램은 OS와 Hardwar에 종속된다. 하지만 JAVA는 JVM을 활용하기 때문에 프로그램이 OS로부터 독립적이게 된다.    

![JAVA 프로그램 실행 구조](https://parkmh04.github.io/images/JVM/JAVA_Excute_Structure.png)    

다만, JAVA로 만든 프로그램은 OS와 별개로 JVM을 실행한 뒤, 그 위에서 실행되기 때문에, 일반적인 프로그램보다 느릴 수 밖에 없다.(높은 성능이 요구되는 게임들과 엔진들은 대부분 C언어로 만들어진다.)    

JAVA Code는 C언어와 달리 기계어로 Compile 되지 않고, JVM이 이해할 수 있는 **Java Byte Code**(.class)로 Complie되며, JVM는 이러한 Byte Code를 한 줄 씩 읽어 번역한 뒤, 실행하게 된다.(Interpreter)  

> **Java Byte Code Viewer**  
JAVA의 Byte Code 어떻게 생겼는지 궁금할 경우, Debugging 해보면 된다.  
1) Eclipse Market Place에서 Bytecode Visualizer를 Plug-in으로 설치  
2) ByteCode View라는 별도의 프로그램을 설치  

**Byte Code Visualizer(Eclipse Plug-in)**  
![JAVA Visualizer](https://parkmh04.github.io/images/JVM/BytecodeVisualizer.png)    

> ByteCode Viewer의 경우, Complie된 Byte Code를 JAVA Code로 Decompile하여 볼 수도 있고, Hexa Code, Byte Code 형태로 Debugging 할 수 있는 강력한 Tool이다.  
ByteCode Viewer는 http://bytecodeviewer.com/ 에서 다운받을 수 있다.    

**Byte Code Viewer**  
![ByteCode View home](https://parkmh04.github.io/images/JVM/BytecodeViewer_home.png)    

> ByteCode View를 실행하면, 다음과 같은 화면이 나타난다.  

![ByteCode View Excute](https://parkmh04.github.io/images/JVM/BytecodeViewer_Excute.png)    

> ByteCode Viewer를 실행한 뒤, Apache Log4j의 Category.class를 조회해봤다.  왼쪽에 보이는 화면이 ByteCode이며, 오른쪽에 보이는 화면은 ByteCode를 Decomplie한 것이다.    

![ByteCode View Decompile](https://parkmh04.github.io/images/JVM/BytecodeViewer_Decompile.png)    

> ByteCode Viewer를 이용할 경우, JVM이 실행하는 ByteCode를 Dubugging할 수 있으며, 악성코드의 포함여부를 확인하는 것이 가능하다.(한글 보기 지원함)  

Byte Code는 기계어에 비해 Decompile이 쉽기 때문에, 악용되는 사례도 많다. 따라서 APP과 같이 **외부에 노출되는 프로그램은 반드시 난독화를 적용해야 한다.**    

**Byte Code를 활용하는 선인과 악인**    
**박XX** : Exception Class의 구조가 궁금하네, JD-Eclipse로 공부해봐야겠다. :)  
**성XX** : 우헤헤. 요즘 벌이도 시원찮은데, 저 게임을 내가 베껴서 돈 벌어야겠다. 우헤헤.    

그렇다면, Byte Code로 Compile된 Code를 JVM은 어떻게 실행하게 되는 걸까.  
JVM의 동작원리를 살펴보기 위해서는 JVM의 특성과 JVM의 구조를 알아야한다.    

---

### 2. JVM Structure    
![JVM_Structure](https://parkmh04.github.io/images/JVM/JVM_Structure.png)  

JAVA Compiler(Javac.exe)에 의해 Complie된 ByteCode(.class)들은 JVM의 ClassLoader System에 의해 Load 되고, Execution Engine에서 이 Class들을 한 줄 씩으로 읽어서 해석(Interpret)한다.  

Exceution Engine에서 해석된 ByteCode들은 JVM의 메모리(Runtime Data Area)에 할당되게 되는데, 그 역할에 따라 저장되는 영역과 방법이 달라지게 된다.

> **Class Loader**  
- JVM 시작시 Bootstrap Class Loder와 그 자식 Class Loader들을 생성하고, Object를 비롯한 Java Class들을 **Loading**한다.  
- Load된 Class가 JAVA 명세에 맞는 지 **Verify**한다.  
- Class가 필요로 하는 메모리를 할당하고, Class의 변수, 함수, 인터페이스를 구조화하여 Runtime Data Area에 **Store**한다.    

**Class Loader Structure**  
![ClassLoader_Structure](https://parkmh04.github.io/images/JVM/ClassLoader_Structure.png)    

> **Exceution Engine**  
- ByteCode를 Line 단위로 읽고 해석(ByteCode를 기계어로 변환)하여 실행한다.  
- 한 줄씩 읽어서 실행하는 단점으로 인해 JIT(Just-in-Time) Complier를 사용하기도 한다. 다만 모든 Java Class에 JIT를 사용하지는 않는다(비용이 많이 듬)    

> **Runtime Data Area**(JVM Memory)  
- JVM은 OS로부터 메모리를 할당받아, Runtime Data Area를 생성하고 사용한다.   
- Class Loader에 의해 Loading된 Class들은 그 구분에 따라 서로 다른 JVM Memory에 보관된다.  
- JVM Memory는 크게 5개의 영역(Method Area, Heap, Stack Area, Native Method Stacks, PC Register)으로 구분한다.  

---

### 3. JVM Memory Structure    
JVM Memory는 크게 5개의 영역(Method Area, Heap, Stack Area, Native Method Stacks, PC Register)으로 구분할 수 있다.    
이중 Method Area, Heap, Runtime Constant Pool(Method Area에 속함)은 모든 Thread가 공유하여 사용하며, Stack Area, Native Mathod Stack, PC Register는
Thread 별로 하나씩 생성하여 사용한다.  

![JVM_Memory_Structure](https://parkmh04.github.io/images/JVM/JVM_Memory_Structure.png)    

> **Method Area(Static Area)**  
- JVM이 시작될 때, 생성된다.  
- Class, Interface, Static 변수, Filed, 생성자, 메쏘드가 저장되는 영역이다.  
- 각 Class와 Interface에 대한 런타임 상수들은 Runtime Contant Pool로 별도로 저장된다.  
- Permanent Area 혹은 Permanent Generation으로 불리기도 한다.  
- Perm Area에 대한 GC(Garbage Collection)는 선택사항이며, Perm Area에 GC는 드물게 일어난다.  
- JVM이 실행되면서 Class Loader에 의해서 Loading된 Class 정보들은 Method Area에 저장되게 되고, 해당 Class의 Instance는 Heap Area에 저장되는 것을 구별해야한다.    

> **Runtime Constant Pool**  
- Type(Class, Interface)의 모든 상수 정보가 저장된다.  
- Type, Constant, Method, Field에 대한 Reference 정보를 저장한다.  
- JVM은 Method를 실행 하기 위해 Runtime Constant Pool에 저장된 Reference를 참조한다.    

> **Heap**  
- Type(Class, Interface)의 Instance와 배열(Reference Type)이 Runtime시 동적으로  저장되는 공간이다.  
- 미리 설정해둔 메모리(시스템의 초기 메모리, 기동메모리로 불림)만큼을 한계로 그 안에서 사용되기 때문에, GC의 대상이 되는 영역이다.    

> **Stack Area**  
- Thread가 시작할 때 할당되며, 메쏘드를 호출할 때마다 저장하고, 해당 메쏘드가 종료되면 제거한다.  
- Static으로 선언되지 않은 메쏘드들이 Class 로딩시 준비된다.  
- 메쏘드 내부에서 사용하는 Parameters, Local Variables, Operation 결과 값들도 저장된다.  
- Primitive Type 변수들이 저장된다.(Reference Type은 Heap)    

**Sample Code**
``` java
// Mehtod Area 저장
public class Test {

	// Mehtod Area 저장
	public static final String VERSION = "1.0.0";

	// Mehtod Area 저장, 실행 시 Stack Area에 저장되었다가 종료시 제거된다.
	public static void main(String[] args) {

			// Char[] 형태로 Heap Area에 저장 
			String str = "발아현미";

			// Stack Area 저장(int cnt, 0) 
			int cnt = 0;

			// Operation은 Stack Area 저장
			cnt++;
			
			// 참조가 종료된 Instance는 GC의 대상이 된다.(Minor)
			str += "좋아";
			
			// System Class는 println() 메쏘드는 Mehthod Area 저장, 실행시 Stack Area에 저장되었다가 종료시 제거된다.
			System.out.println();
	}
}
```    

> **PC**(Program Counter) **Register**  
- Thread가 시작될 때, 생성되며, JVM 내부에서 처리한다.    

> **Native Mathod Stack**  
- 자바 이외의 언어로 작성된 Native Code들이 실행될 시 저장되는 Stack Area  
- JNI를 이용하여 C/C++로 된 Code 호출 시, Method의 Parameters, Local Variables, Operation 결과 값들이 저장(Byte Code)된다.    

---

### 4. Heap & GC    
Heap Area는 크게 Young Generation, Old Generation, Permanent Generation으로 구분된다.  

> **Permanent Generation**  
- JVM Structure의 Method Area(Static Area)에 해당한다.  

> **Young Generation**  
- 객체가 생성되자마자 저장되는 영역이다,  
- Young Generation의 객체가 참조가 해제되면(접근 불가능 상태, unreachable), GC(Minor)가 일어난다.  
- Young Generation의 객체가 일정시간 이상 참조가 유지되면 Old Generation 으로 이동한다.    

Young Generation의 경우, 3개의 영역으로 구분할 수 있다.
- Eden : 새롭게 생성된 객체의 대부분이 저장된다.
- Survivor 0/1 : Minor GC 이후 남은 Eden의 객체가 저장된다. 하나의 Survior가 가득 차게 되면 GC가 일어나게 되며, 살아남은 나머지 객체들은 다른 Survior 객체로 이동한다. 하나의 Survior 영역이 가득 차기 전까지 다른 Survior 영역은 비워진 상태로 존재한다. Survivor 영역 간을 오가는 객체가 시간이 지나면 Old Generation으로 이동한다.    

![Minor GC](https://parkmh04.github.io/images/JVM/MINOR_GC.png)    

> **Old Generation**  
- 참조가 유지되는 객체들 중 오래된 객체가 저장되는 영역이다.  
- Old Generation에서는 일반적으로  데이터가 가득차면 GC(Major, Full)가 일어난다.  
- 보통 Young Generation보다 Old Generation의 할당된 크기가 크기 때문에, GC의 시간이 길다.  

일반적으로 프로젝트 수행시 GC Pattern에 대한 고민과 결정은 SWA들의 몫으로 인식되지만, 이지만, 개발







앞서 명시한 것처럼 Heap은 Runtime시에 Type의 Instance와 Array가 저장된다. 더이상 참조하는 변수가 없는 객체들은 GC(Garbage Collection)의 대상이 되는데, GC는 Heap에 데이터가 계속 쌓여 OOM(Out of Memory)이 발생하지 않도록 할당된 메모리를 제거하는 것을 의미한다.    

C의 경우 소스코드에서 변수에 할당된 메모리를 임의로 해제가능하지만, JAVA에서는 Garbage Collector가 스스로 할당된 메모리를 해제하기 때문에, 개발자가 신경 쓸 필요가 없다는 장점이 있다.  

다만, GC가 일어나는 동안은 GC를 수행하는 Thread를 제외하고는 모든 Thread들이 대기하므로, 개발자 입장에서는 GC가 너무 잦게 혹은 너무 길게 일어나지 않도록 해야한다.  

Heap Area에 Data는 다음과 같은 순서로 저장된다.  
Young Generation > Old Generation



정보가 저장이
Young Generation: 이 영역은 자바 객체가 생성되자마자 저장되고, 생긴지 얼마 안되는 객체가 저장되는 공간이다. 시간이 지나 우선순위가 낮아지면 Old 영역으로 옮겨진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다.
Old(Tenured) Generation: Young Generation 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어 저장되는 영역이다. 이 영역에서 객체가 사라질 때 Major GC(Full GC)가 발생한다.
Permanent Generation: 클래스 로더에 의해 로든되는 클래스, 메소드 등에 대한 메타 정보가 저장되는 영역으로 JVM에 의해 사용된다. 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 내부적으로 리플렉션 기능을 자주 사용하는 Spring Framework를 이용할 경우 이 영역에 대한 고려가 필요하다.

![JVM_Memory_Structure](https://parkmh04.github.io/images/JVM/JVM_Heap.png)    


---

Ref :  
[Bytecode Visualizer](http://noentrypoint.blogspot.kr/2014/02/java-bytecode-debugging.html){: target="_blank" }    
[ByteCode View를 활용한 APK 분석](https://brunch.co.kr/@c4u/23){: target="_blank" }    
[왜 JVM의 구조를 이해해야 하는가](http://bitacademy.96.lt/wp/java/%EC%99%9C-jvm%EC%9D%98-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80/){: target="_blank" }    
[NAVER JVM Internal](http://d2.naver.com/helloworld/1230){: target="_blank" }    
[JD-Clipse Home](http://jd.benow.ca/){: target="_blank" }    
[JAVA의 Class Loader](http://javacan.tistory.com/entry/1){: target="_blank" }    
[Oracle JVM 명세](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html){: target="_blank" }    
[변하는 것은 변하지 않는다 - JAVA JVM](http://cleancodes.tistory.com/6){: target="_blank" }    
[훈마로의 보물창고 - 자바 메모리 구조](http://hoonmaro.tistory.com/19){: target="_blank" }    
[자바에 메모리가 저장되는 구조와 원리](http://jhleed.tistory.com/36){: target="_blank" }    
[자바 메모리 구조](http://myeonguni.tistory.com/60){: target="_blank" }    
[NAVER GC](http://myeonguni.tistory.com/60){: target="_blank" }    

